* Understanding Lisp in Very Little Time

** Caveats: Read this first

It's much easier to implement Lisp than most other programming languages. This
has led to the Lisp Curse: Many individuals and institutions have created their
own dialects of Lisp, each a bit deviant from the others or either of the two
major standards. Fortunately, most dialects of Lisp are more alike than they are
different. If you have experience with one Lisp it's generally easy to learn any
other Lisp. The examples we're giving here are based on the influential and
especially elegant (simple yet powerful) Lisp dialect /Scheme/ as implemented in
the /Racket System/.

NOTE: This claim to simplicity applies only to /the language itself/. In
practice, you'll be using various libraries which extend the base language with
special types and procedures. You'll need to study the details of any such
features your program is using. While this is true with /any/ programming
language, Lisp allows such libraries to significantly extend Lisp's syntax and
semantics: For this reason, Lisp is often called /the programmable, programming
language!/

** Lisp expressions use Nested Lists!

A humorous definition of Lisp:
- *Lisp:* Lots of Irritating Silly Parentheses

Let's compare Lisp with some popular languages which use /algebraic syntax/
- e.g. Java, JavaScript, C, Python, Rust, etc.

- Algebraic operator syntax: =a + b + c + d=
- Lisp: =(+ a b c d)=

- Algebraic function calls: =f(a,b,c)= and =f(a,g(b,c),d)=
- Lisp: =(f a b c)= and =(f a (g b c) d)=
- /Function =g= is nested inside function =f= in both notations./

Is the Lisp notation more complex?
- Lisp Programmers claim that after a few days of experience Lisp's syntax
  becomes as clear and pleasant as /algebraic syntax/
- Do you think that claim is possible?

A key feature to Lisp syntax is that all Lisp expressions can serve as /both
code and data/, e.g. the Lisp expressions
- =(+ a b c d)=, =(f a b c)= and =(f a (g b c) d)=
can be executed as part of a program or manipulated as data.
- This feature is sometimes a great advantage!

** Lisp Syntax

/Syntax/ defines what a language looks like, not what it does. Syntax is
therefore relatively superficial. Lisp has the simplest syntax of any popular
modern language. Once you learn it, you're unlikely to ever forget it.

Lisp Programs are made out of *Symbolic Expression* defined as follows:

*Atom:* Anything /NOT/ a /List/
- Atoms can be simple, e.g. a character or a number
- Or complex, e.g. /string/, /record/, etc.
*List:* A flexible, extensible sequence of arbitrary elements
- Lisp syntax uses parentheses
*Symbolic Expression aka S-Expr:* Either
- An /Atom/
- A /List/ of /Symbolic Expressions/
      - The empty list: =()=
      - A list of three numbers: =(1 3/4 3.14159 -10+5i)=
      - Another list of 3 elements: =(1 "two" (buckle my shoe))=
            - An integer number, a string and a list of symbols
            - /Note how we can freely nest lists inside of lists/

Each kind of /Atom/ has its own syntax.
- You can add new atom types!
- e.g. [[https://docs.racket-lang.org/quick][Racket Slideshow]] adds atoms which are [[https://docs.racket-lang.org/pict][pictures]].
- You can design the syntax and semantics for a new atom type!

Symbols are atoms which can be used to identify values or which can be used as
values themselves.
- Symbols can be short or long sequences of printable characters
      - except for the special characters ( ) [ ] { } " , ' ` ; # | \
      - or anything which would look like a number.
- Here are seven short symbols: x y n + - * /
- Here are two longer symbols: greet person-name-as-string
- Your symbol spelling should be meaningful to you, Lisp doesn't care!

** Lisp Semantics: =eval=, =apply=

Semantics defines what a /symbolic-expression/ means as /code/, i.e. what
happens when the computer /evaluates/ it. The Semantics of a language is the big
deal. Lisp has the simplest semantics of any popular modern language. Once you
learn it, you're unlikely to ever forget it.

Note: Code can either be directly evaluated by an /interpreter program/
(software) or it can be translated into /machine code/ by a /compiler/ and then
interpreted directly by your CPU (hardware). Lisp systems can use either
approach and typically use both.

*** Environments Supply Context For Evaluation

Lisp evaluates your S-Exprs using the procedures =eval= and =apply= in the
context of /an Environment/

- *Symbol:* An Atom which can serve as a name
- *Value:* An /S-Expr/ which can be /returned/ from a /procedure/
- *Binding:* A /symbol/ "bound to" (associated with) a /value/
- *Environment:* a set of /Bindings/, like a /dictionary/

Here's an example:

#+begin_src racket
  ; Lisp comments follow a ; and are ignored
  ; This is a Racket Program
  #lang racket
  ; Which adds three bindings to the current Environment
  (define advice "Don't Panic!")
  (define answer 42)
  (define shopping '(bread milk))
  ; and then prints those values on separate lines
  (println advice)
  (println answer)
  (println shopping)
#+end_src

The symbols =advice=, =answer= and =shopping= are being used as identifiers.

The symbols =bread= and =milk= are being used as values.

When you run that program, it will print
#+begin_example
Don't Panic!
42
(bread milk)
#+end_example

There are a few other things going on in this example which we'll explain
shortly!

*** How Evaluation Works

The built-in procedures =eval= and =apply= do the work.

The Lisp procedure =eval= takes an /S-Expr/ and returns its /Value/.

There are two rules for atoms (non-lists):

*Symbols:* =eval= returns value from environment /or signals error if none/

*All other atoms:* =eval= returns the atom unchanged

*Evaluable Lists* are called *Forms*

*Evaluating Regular Forms*:

1. /All Elements/ of /Regular Forms/ are /evaluated/
       - /recursively when nested/
       - The /first element/ must evaluate to a procedure (or an error is
         signaled)
2. =apply= calls the procedure, /applying it/ to the other values
       - the other values from the form serve as /arguments/
       - Arguments must be suitable values for the procedure's corresponding
         /parameters/

*Procedure:* An expression providing /instructions/ a computer can perform,
  often referencing /parameters/ which must be provided with values (arguments)
  when the procedure is executed. Procedures are often called /functions/, but
  more on that later.

That's Lisp Semantics in a Nutshell!

*** An Example Lisp Evaluation

#+begin_src racket
  ; In this Racket Program
  #lang racket
  ; With this procedure
  (define (greet s)
    (string-append "Hello " s ", how are you?") )
  ; The expression
  (greet "Dana")
  ; Evaluates to
  "Hello Dana, how are you?"
#+end_src

Let's explain this example, feature by feature:
       - =(define (greet s) (string-append "Hello " s ", how are you?"))=
             - Creates a procedure bound to the symbol =greet=
             - in the current (/global/ or /top-level/) environment.
             - The symbol =s= will be bound in a local environment when the procedure
               is evaluated.
             - Instead of a short name like =s= you could use something more
               explanatory, like =person-name-as-string=.
                   - Lisp doesn't care what you call things.
                   - There's an art to choosing names which are clear to humans
                     without being annoyingly verbose!
             - Elements in a list are generally separated by /whitespace/
                   - One or more /spaces/, /tabs/ or /newlines/
                   - /whitespace/ around (parentheses) and some other /special
                     characters/ is optional
             - /Pretty-Printing/ makes s-expressions easy to read (with experience)
                   - Using some extra /whitespace/
                   - Complex nested lists broken up over multiple lines
                   - with spaces or tabs showing the nesting level.
       - =(greet "Dana")= 
             1. Each element is evaluated
                    - =greet= evaluates to the procedure we defined
                    - ="Dana"= evaluates to itself
             2. We =apply= the procedure to the argument(s)
                    1. =apply= creates a temporary nested /local/ environment
                           - =s= is locally bound to ="Dana"=
                    2. We evaluate =(string-append "hello " s ", how are you?")=
                           1. Each element is evaluated
                                  - string-append= evaluates to a procedure in the string library
                                  - =s= evaluates to ="Dana"=
                                  - The "string literals" evaluate to themselves
                           2. The library procedure is applied to its three arguments
                                  - "Hello Dana, how are you?" is returned

*** Don't Worry, Just Trust!

Although evaluation proceeds in a nested (recursive) fashion, we don't try to
follow that. When we're reading or writing Lisp code, we follow the principle of
/induction/:
- We consider only one procedure at a time
- We treat any nested procedure calls as /black boxes/
- We trust that the nested calls act according to their documentation
We can open up those /black boxes/ at a later time

Local environments are nested inside of the environments which enclose them,
creating what we call /scopes/. This idea was invented by Lisp and is now used
by nearly all modern languages. It allows any expression to use any symbol in
any of the enclosing environments as long as the symbol names don't conflict.

For convenience is using procedures as black boxes
- You can lookup library procedures in the [[https://docs.racket-lang.org/reference][Racket Reference Manual]]
- And if you're using the [[https://docs.racket-lang.org/drracket][DrRacket Programming Environment]]
      - put the cursor on the symbol you want to look up and press =F1=

** Special Semantics for Special Forms

Okaaaay, it's not quite that simple - there are exceptions!

/Special Forms/ are Lists beginning with the name of a symbol that looks like it
could be the name of a /procedure/, but instead, it's a marker for special
treatment.

- =eval= has a special rule for each /Special Form/
- Every Lisp has a small number of built-in /Special Forms/
- /Scheme/ has 5 which you need to learn - how about now?

=quote=: suppresses evaluation of its single argument
- =(quote ANY-SEXPR)= evaluates to =ANY-SEXPR=
- e.g. =(quote (+ 1 2 3))= evaluates to =(+ 1 2 3)= /not/ =6=!
- Lisp has a special shorthand syntax for =quote=
- ='X= is a shorthand for =(quote X)= for any X
- so ='(1 2 3)= is a shorthand for =(quote (1 2 3))=

=(if TEST IF-TRUE IF-FALSE)= evaluates =TEST=, then either =IF-TRUE= or =IF-FALSE=
- =TEST=: an S-Expr which evaluates to a /Boolean truth value/
- The atom =#f= is the /Boolean Value/ for /false/
      - all other S-Exprs are considered /true/
      - the atom =#t= is the /canonical/ Boolean Value for /true/
- thus =(if TEST IF-TRUE IF-FALSE)=
      - evaluates =TEST=
      - evaluates =IF-TRUE= if =TEST= is true, i.e. not =#f=
      - evaluates =IF-FALSE= if =TEST= is false, i.e. =#f=
- so =if= only evaluates two of its three arguments!

=(define SYMBOL VALUE)= binds =SYMBOL= to the given /VALUE/
- in the current /environment/
- Special features of =define=
      - it does NOT evaluate its first argument
            - the SYMBOL is implicitly quoted
      - it does NOT return a normal value
            - you can't use a nested define as an argument
      - modifying an existing object is called a /side-effect/
            - here the existing object is the environment
      - In Racket, the modification must be /monotonic/
            - the symbol must not already have a value

=(set! symbol value)= /changes/ the binding of =symbol= to a new value
- Special features of =set!=
      - it does NOT evaluate its first argument
            - the symbol is implicitly quoted
      - it does NOT return a normal value
            - you can't use a nested define as an argument
      - In Racket, the modification must be /non-monotonic/
            - the symbol must already exist and already have a value
      - Lisp programmers try to avoid /non-monotonic side-effects/!
            - Names of Scheme non-monotonic functions often end with =!=
            - This is intended as a warning!

=(lambda PARAMETERS BODIES)= creates a procedure
- *PARAMETERS:* a list of 0 or more /symbols/
      - or a single /symbol/ which gets /all PARAMETERS/ as a /list/
- *BODIES:* 1 or more S-Exprs to evaluate.
      - The value of the last body is /returned/ as the value of the
        procedure call
- *when the procedure is called*
      - each of the /PARAMETERS/ will require a suitable /argument value/
      - a new nested environment will be created in which
      - the /PARAMETERS/ will be /bound/ to the corresponding /arguments/
      - the BODIES will then be evaluated in that extended environment

** Syntactic Sugar helps in digesting complex code

With apologies to the [[https://www.youtube.com/watch?v=_L4qauTiCY4][musical Mary Poppins]] programming languages often provide
special syntax that isn't strictly necessary but which makes code easier to
read or write.  This is often called /Syntactic Sugar/.

The most obvious piece of /Syntactic Sugar/ you'll see in /Scheme/ programs is
the use of =define= to create procedures.  When you see

#+begin_src racket
  #lang racket
  (define (greet s)
    (string-append "Hello " s ", how are you?") )
#+end_src

is using syntacatic sugar.  What's really going on is

#+begin_src racket
  #lang racket
  (define greet (lambda (s)
    (string-append "Hello " s ", how are you?") ))
#+end_src

Properly
- =define= creates a binding in the /current environment/
- =lambda= creates a procedure which is a first-class Lisp value

Lisp is based on the mathematical model of computation called the /Lambda
Calculus/. The most powerful operator in that model is =λ= or =lambda=.

The /Lambda Special Form/ is one of the most powerful features of Lisp. As you
begin to master Lisp you will make more and more use of /Lambda/ and you will
find more instances of [[file:lambda-sugar.rkt][Lambda Sugar]] in Lisp.

One of the most touted features of Lisp is a feature called /Macros/. /Macros/
allow programmers to define new /Special Forms/. This feature should be used
sparingly. Macros can sometimes help abbreviate complex syntax, but they can
also confuse someone trying to understand your program since they alter the
normal Lisp execution mechanism.

** Functions and Functional Programming

Many people in computing use the terms /procedure/ and /function/
interchangeably, but a /functional procedure/ is something special.

*functional procedure:* A /procedure/ which
- returns the same value when given the same argument values
- does not directly or indirectly modify anything outside of itself
- Functional Procedures are simpler, leading to fewer errors

/Functional Programming/ is programming using only /Functional Procedures/
- Functional Programming is /possible/ in Lisp
- Functional Programming is /not at all required/ in Lisp

Modern Lisp programmers prefer using Functional Procedures
- Except where it's significantly inconvenient
- Don't worry, you'll catch on!

*** We're done!

That's it! That's how Lisp works!

But how do you go about developing Lisp Programs? Most Lisp Programmers prefer
to develop their Lisp Programs interactively, using a /REPL/. /DrRacket/
provides a /REPL/ in the /Interaction Window/ along with additional windows in
which you can save your results to a file. Most Lisp Development Environments,
such as those based on the /Emacs Platform/ (written in Emacs Lisp) provide
similar functionality.

** Interactive Lisp uses a (P)REPL

- (P)REPL:* (Prompt) Read Eval Print Loop session
- *You enter:* (+ 1 (* 3 4) 5)
- =eval= calls itself recursively to obtain =(#<procedure:+> 1 12 5)=
- =eval= calls =apply= with #<procedure:+> and =(1 12 5)=
- *The final result is printed:* =18=
- How did =(* 3 4)= become =12=?

(P)REPL Session
- =(quote (+ 1 (* 3 4) 5))=
      - =(+ 1 (* 3 4) 5)=
- =(apply + '(1 2 3 4 5 6))=
      - =21=
- =(map eval '(+ 1 (* 3 4) 5))=
      - =(#<procedure:+> 1 12 5)=
- =( (lambda (x y) (+ (* x x) (* y y)) ) 3 4 )=
      - evaluates =(+ (* x x) (* y y))=
      - in the environment extended with =(x 3) (y 4)=
      - which =eval= turns into =(#<procedure:+> 9 16)=
      - and =apply= turns into =25=

Calls on built-in atomic procedures such as the atoms =#<procedure:+>= and
=#<procedure:*>= will be compiled to inline machine code instructions where
possible and to machine code procedure calls when necessary.

Like everything else in Lisp. /procedures/ are /first class values/, i.e.
- they can be bound to a symbol
- they can be passed to a procedure as an argument
- they can be returned from a procedure as the procedure's computed value

As you work at the REPL, you save the functions you like in files which evolve
into structured modules. Development sessions typically begin with loading the
modules you've built so far into the REPL and then you work interactively and
incrementally at creating new modules as well as improving the existing modules.
A good /Lisp Development Environment/ will typically provide many features which
extend the REPL to assist you with this kind of /incremental development
process/.  This is all something to grow into gradually!

** Built-In and Library-Provided Atom Types and Procedures

The last two practical barriers to understanding a Lisp program is that you have
to understand the atoms and procedures which your Lisp provides in its standard
profile and which you import from libraries. When you're studying code written
by others you may have a lot of things to track down in order to understand how
that code works.

Each atom type has a syntax which will be read by the =read= procedure. For
example, /character Strings/ are enclosed in double quotes, with a special
/escape syntax/ for embedded special characters. The various kinds of numbers
generally have the same syntax as other languages, except that many Lisps
include more kinds of numbers, e.g. rationals and complex numbers. The =print=
procedure also has to know that syntax so that it can print them properly. In
Racket's /Slideshow Language/ =print= knows how to print pictures.

In addition to (usually) building in a lot of powerful atom types and procedures
which might be useful in your programs, your Lisp will come with lots of
libraries which bring in new atom types and powerful procedures. You will need
to study the documentation for any built-in features or libraries you use. Your
development environment, e.g. DrRacket or Emacs will usually provide a handy
mechanism for going from any unfamiliar entity in your source code to the place
in your Lisp's documentation which defines that construct or procedure.

*** Racket vs. Scheme

[[https://racket-lang.org][Racket]] began as an implementation of the [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme Programming Language]], the
simplest of the two standardized dialects of Lisp. Over the years Racket added
many additional features but maintained compatibility with Standard Scheme. Most
Lisps allow the programmer to break a program down into modules which can be
developed separately and then combined to produce complete programs. The Racket
developers added a feature, =#lang= to specify which language a given Racket
Module was written in, along with creating several interesting languages which
are /not/ compatible extensions of Standard Scheme. Racket provides the ability
to combine Racket Modules written in different Racket languages into a single
program. The =#lang= declaration at the top of a Racket Module tells Racket
which of the Racket Languages you're meaning to use in the current module so
that Racket can understand you properly.

** An Interactive Example Program

Here's an example which you can study and run.

This example contains some library functions that begin adding a capability to
interact with a user.

It also uses a few gratuitous but popular special forms you may want to use in
your own programs.

You can guess how it works, run it and experiment with variations.

When you want to fully understand it, you can look up any of the functions or
special forms in the reference manual as explained above.

#+begin_src racket
    #lang racket
    (define (assess n)
      (printf (if (eq? n 42)
                  "Yes, but why is ~s the answer?\n"
                  "No, ~s is not the answer!\n" ) n ) )
    (define (play)
      (printf "What is the answer? [q to quit] ")
      (let ( [response (read)] )
        (if (eq? response 'q)
            (printf "Thanks for playing, goodbye!\n")
            (begin (assess response)
                   (when (not (eq? response 42)) (play)) ) ) ) )
    (play)
#+end_src

** Would you like to learn more?

In order to present the elegant simplicity at the heart of Lisp, this document
skipped over some [[file:lisp-complications.org][Lisp Complications]] which you might want to learn about soon.

Read [[lisp-systems.org][Lisp Systems]]

Study the [[vis-mce.rkt][Meta-Circular Interpreter]] which defines Lisp in Lisp!

Join a [[https://github.com/GregDavidson/computing-magic][Computing Magic]] study group?

Ask questions!
- Post issues on GitHub

Help improve these materials!
- Fork this repository
- Improve your copy of it
- Send us a /pull request/ with your improvements!
